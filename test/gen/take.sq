five :: { Int | _v == 5 }

data Expr a where
  Eq :: x: a -> Expr a
  Neq :: x: a -> Expr a
  Lt :: x: a -> Expr a
  Gt :: x: a -> Expr a
  And :: lhs: Expr a -> rhs: Expr a -> Expr a
  Or :: lhs: Expr a -> rhs: Expr a -> Expr a

measure eval :: v: a -> Expr a -> Bool where
  Eq x -> v == x
  Neq x -> v != x
  Lt x -> v < x
  Gt x -> v > x
  And lhs rhs -> eval v lhs && eval v rhs
  Or lhs rhs -> eval v lhs || eval v rhs

measure not :: Expr a -> Expr a where
  Eq x -> Neq x
  Neq x -> Eq x
  Lt x -> Or (Gt x) (Eq x)
  Gt x -> Or (Lt x) (Eq x)
  And lhs rhs -> Or (not lhs) (not rhs)
  Or lhs rhs -> And (not lhs) (not rhs)

g :: x: Expr Int -> { Int | eval _v x }
g_not :: x: Expr Int -> { Int | eval _v (not x) && !(eval _v x) }

-- rand_int :: Expr Int

type Nat = {Int | _v >= 0}

data List a where
	Nil :: List a
	Cons :: x: a -> xs: List a -> List a

termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons y ys -> 1 + len ys

take5 :: x: List Int -> { List Int | len _v == 5 }
take5_x_not :: x: List Int -> x_not: { List Int | !(len _v == 5) } -> Int

gen_range :: Int
gen_range =
  let x = (?? :: Expr Int) in
  let x_value = g x in
  let _ = range_x_not x_value (g_not x) in

  range x_value y_value z_value
